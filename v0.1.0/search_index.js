var documenterSearchIndex = {"docs":
[{"location":"misc/todo/#Tasks-1","page":"Tasks","title":"Tasks","text":"","category":"section"},{"location":"misc/todo/#","page":"Tasks","title":"Tasks","text":"List of tasks, roughly in order of completion and priority:","category":"page"},{"location":"misc/todo/#Done-1","page":"Tasks","title":"Done","text":"","category":"section"},{"location":"misc/todo/#","page":"Tasks","title":"Tasks","text":"[x] updating with additional tests/features from cfgrib.py\nnew test file: forecast_monthly_ukmo\naddition of date_key=\"indexingDate\" and time_key=\"indexingTime\"\n[x] added CompatHelper for automated dependency updates (similar to Dependabot)\n[x] segfaults in GRIB.jl\n@Robert to open an issue on GRIB.jl on GitHub and mention Stephan, so that he is in the loop.\nProblem ended up being with Julia, not GRIB.jl!\nhttps://github.com/JuliaLang/julia/issues/36422\nTuples over 64 items caused a segfault with the unique function\n[x] adding in xarray-like backends\nmade flexible backend system that allows for multiple/no backends to be loaded dynamically\ntwo backends present: AxisArrays and DimensionalData\nboth are relatively basic wrappers around my DataSet types\nfeatures like pretty printing, conversion, clever-ish getindex/getproperty\n[x] tests","category":"page"},{"location":"misc/todo/#In-Progress-1","page":"Tasks","title":"In Progress","text":"","category":"section"},{"location":"misc/todo/#","page":"Tasks","title":"Tasks","text":"[~] FileIO integration\n90% done, integration is set up in the code, but for full integration a PR to FileIO is required\nwill wait until package is on the Julia Package Registry to do that\n[~] started work on documentation\n[ ] fill in all user-facing docstrings\n[ ] setting up documentation deployment\n[ ] integrate doctests with rest of CI\n[ ] examples\n[ ] add in badges\n[~] working on GitHub Workflow CI instead of travis\nin theory more flexible, if it works properly...\n[~] logging\nIain reports that logging is only used to report problems.\nIn Julia, there are built-in logging functionalities. Stephan would be interested in seeing warnings/errors in Julia\n@Robert to look into that\nsome logging already present, need to flesh out the rest","category":"page"},{"location":"misc/todo/#Todo-1","page":"Tasks","title":"Todo","text":"","category":"section"},{"location":"misc/todo/#","page":"Tasks","title":"Tasks","text":"[ ] filter by keys examples\nIain suggested that to look at the top level README for examples of filterbykeys, missing in tests\n@Robert to look into that\n[ ] intensive real-life examples\nRobert cannot implement any Julia specific optimisations because he does not have a non-trivial example.\n@Shahram can provide stress tests for eccodes\n@Iain can provide an example using very high horizontal resolution and numerous vertical levels","category":"page"},{"location":"misc/todo/#Backlog-1","page":"Tasks","title":"Backlog","text":"","category":"section"},{"location":"misc/todo/#","page":"Tasks","title":"Tasks","text":"[ ]cfmessage conversion methods\nI ain checked and found a test for the first three, but last one is not used/tested.\n[ ] tiny questions\nThe version is in GitHub.\n@Robert to file a feature request to add a function to expose the version.\n[ ] Additional questions:\nSharam suggested to use code coverage on the GitHub repo. Robert mentioned there is already code coverage for cfgrib.jl but not for GRIB.jl\n@Robert to mention this to the developer of GRIB.jl\n[ ] use of history\nIn Julia it's not easy to convert dictionary to string. Is this functionality needed? Should Robert implement it?\nIain mentioned this is optional to have.","category":"page"},{"location":"lib/internals/indexing/#","page":"Indexing","title":"Indexing","text":"Author = \"Robert Rosca\"","category":"page"},{"location":"lib/internals/indexing/#lib_indexing-1","page":"Indexing","title":"Indexing","text":"","category":"section"},{"location":"lib/internals/indexing/#","page":"Indexing","title":"Indexing","text":"GRIB.jl is by CfGRIB to read the GRIB files, GRIB.jl provides its own ways to create, read, and filter an index, however cfgrib.py uses a different approach to indexing. So, CfGRIB.jl, being based on the python implementation, recreates the python approach instead of integrating with the GRIB.jl indexing approach.","category":"page"},{"location":"lib/internals/indexing/#","page":"Indexing","title":"Indexing","text":"The indexing file defines the FileIndex type, as well as the constructors for that type.","category":"page"},{"location":"lib/internals/indexing/#","page":"Indexing","title":"Indexing","text":"","category":"page"},{"location":"lib/internals/indexing/#","page":"Indexing","title":"Indexing","text":"Modules = [CfGRIB]\nPages   = [\"indexing.jl\"]","category":"page"},{"location":"lib/internals/indexing/#","page":"Indexing","title":"Indexing","text":"Modules = [CfGRIB]\nPages   = [\"indexing.jl\"]","category":"page"},{"location":"lib/internals/indexing/#CfGRIB.FileIndex","page":"Indexing","title":"CfGRIB.FileIndex","text":"Summary\n\nmutable struct FileIndex\n\nA mutable store for indices of a GRIB file\n\nFields\n\nallowed_protocol_version::VersionNumber\nVersion number used when saving/hashing index files, should change if the indexing structure changes breaking backwards-compatibility\ngrib_path::String\nPath to the file the index belongs to\nindex_path::String\nPath to the index cache file\nindex_keys::Array{String,1}\nArray containing all of the index keys\noffsets::Array{Pair{NamedTuple,Int64},1}\nArray containing pairs of offsets[HeaderTuple(header_values)] => offset_field\nmessage_lengths::Array{Int64,1}\nArray containing the length of each message in the GRIB file\nheader_values::OrderedCollections.OrderedDict{String,Array}\nDictionary of all of the loaded header values in the GRIB file\nfilter_by_keys::Dict\nFilters used when creating the file index\n\nConstructors\n\nFileIndex()\n\nFileIndex(grib_path, index_keys)\n\n\n\n\n\n","category":"type"},{"location":"misc/questions/#cfgrib-questions-1","page":"Meeting Notes","title":"cfgrib questions","text":"","category":"section"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"Some questions I need input on, in no particular order:","category":"page"},{"location":"misc/questions/#logging-1","page":"Meeting Notes","title":"logging","text":"","category":"section"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"How is the logging functionality usually used? So far I just haven't implemented it, for when I do it would be useful to know if it's only (or primarily) used for developing and debugging the package, or if it is actually used to log info for data analysis by users (not developers) of the package.","category":"page"},{"location":"misc/questions/#offsets-1","page":"Meeting Notes","title":"offsets","text":"","category":"section"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"There is a discrepancy between how offsets are defined and used in cfgrib with the GRIB file seek method and in the Julia GRIB package, in Julia seek seeks through the messages themselves not the actual offset values.","category":"page"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"This is probably due to me making a mistake, don't know enough about GRIB spec to figure out how this should be done.","category":"page"},{"location":"misc/questions/#filter-by-keys-examples-1","page":"Meeting Notes","title":"filter by keys examples","text":"","category":"section"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"Would be nice to see some examples of how and when filter_by_keys is used so that I can add in some tests for it.","category":"page"},{"location":"misc/questions/#use-of-history-1","page":"Meeting Notes","title":"use of history","text":"","category":"section"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"How is the history field used? There are some problems with correctly escaping quotes and making the string look like a dictionary in Julia, so right now it's not really equivalent to the python version.","category":"page"},{"location":"misc/questions/#OnDiskArray-dtype-1","page":"Meeting Notes","title":"OnDiskArray dtype","text":"","category":"section"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"The OnDiskArray class in Python has a dtype filed which is always set to Float32, is the multidimensional message data in GRIB always that type, or should I try to infer what type it is from the file and then set the type of the OnDiskArray to match that?","category":"page"},{"location":"misc/questions/#cfmessage-conversion-methods-1","page":"Meeting Notes","title":"cfmessage conversion methods","text":"","category":"section"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"There are a few methods in cfmessage which aren't called by the tests, so I haven't added their equivalents in yet for Julia. Could I have some examples for these being called:","category":"page"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"to_grib_date_time\nfrom_grib_step\nto_grib_step\nfrom_grib_month","category":"page"},{"location":"misc/questions/#intensive-real-life-examples-1","page":"Meeting Notes","title":"intensive real-life examples","text":"","category":"section"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"There's quit a bit of optimisation that I could apply to make the package both faster to use on its own, or to make it easier to use it with other tools (e.g. outputting shared or distributed arrays for parallelised tasks; CuArrays for GPU tasks), but I need an example of real analysis code that calls cfgrib for this. It's hard to optimise the code without seeing real usecases.","category":"page"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"Also I'm at the stage where I need to make some decisions on how users interface with the functions, it's hard to figure out the right design without seeing how people currently use cfgrib.","category":"page"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"A non-trivial example going through a decent amount of data would also let me create a performance benchmark, which is important for the development of the package but also lets me show a concrete python vs. julia example of how julia code should be written.","category":"page"},{"location":"misc/questions/#wrong-increment-loading-behaviour-1","page":"Meeting Notes","title":"wrong increment loading behaviour","text":"","category":"section"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"My automated parity tests between julia and python showed python returns data for the u10 variable in regular_gg_wrong_increment.grib, whereas Julia throws an error DimensionMismatch(\"new dimensions (192, 64) must be consistent with array size 18432\").","category":"page"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"This happens because the u10 variable contains an array of 18 432 values, but it gives dimensions of (192, 64), which is only 12 288 values, so there are 6 144 more values in than would fit in the array.","category":"page"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"In python, the assignment to the array is done with:","category":"page"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"array_field.__getitem__(tuple(array_field_indexes)).flat[:] = values","category":"page"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"Which means that the last values are discarded.","category":"page"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"I can easily implement the same behaviour in Julia, but is this really intended? Those values aren't missing, they contain actual data which is just thrown away, in my mind this should throw an error by default, but there could be a discard or force_fit flag which allows data to be thrown away.","category":"page"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"The flag could have values of false (default), end (discard data at the end of the array, current behaviour in python) or start (discard data at the start instead).","category":"page"},{"location":"misc/questions/#segfaults-in-GRIB.jl-1","page":"Meeting Notes","title":"segfaults in GRIB.jl","text":"","category":"section"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"This is completely beyond my skills, I use GRIB.jl to open and read the GRIB files. GRIB.jl provides an interface to eccodes. For some reason I don't understand, GRIB.jl throws a segfault error when trying to read the sample file reduced_gg.grib.","category":"page"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"Julia calls to c are native, so (I assume) debugging this should be relatively straightforward for somebody who knows the interface to eccodes well, but that's not me :P could I get some help with tracking down this issue?","category":"page"},{"location":"misc/questions/#tiny-questions-1","page":"Meeting Notes","title":"tiny questions","text":"","category":"section"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"How can I pull out the version of eccodes? It's stored in the history but I don't know hot to get it.","category":"page"},{"location":"misc/questions/#Meeting-Notes-1","page":"Meeting Notes","title":"Meeting Notes","text":"","category":"section"},{"location":"misc/questions/#","page":"Meeting Notes","title":"Meeting Notes","text":"make grib.jl issue about segfaults and @ steffen\nwrong increment loading behaviour\ncalculate increment and dimensions from the first bits of information\ngrib devided into sections, section describes grid geometry information\nother section contains the data\narray of values can be out of sync with the grid geometry\nlogging only for debugging\nwarn, error, critical, level logging in julia\noffsets\neach message is self contained\nmessage number (count key) starts from 1\noffset is a long integer which is the BYTE OFFSET OF THE MESSAGE IN THE FILE\nseeking to the byte offset puts you at the beginning of the message\nuse readme file as tests for filter by keys\nhistory shouldn't matter much, just leave it as a list of processing steps\nOnDiskArray leave as float32\ncfmessage conversion methods\nthese methods to have some tests:\ntogribdatetime, fromgribstep, togrib_step\nlook for the eccodes c-engine on github to see the version\neccodes-python python bindings have the way to get the versions\nrequest GRIB.jl to add a versions method in\nask GRIB.jl author about adding in tests","category":"page"},{"location":"lib/internals/dataset/#","page":"Dataset","title":"Dataset","text":"Author = \"Robert Rosca\"","category":"page"},{"location":"lib/internals/dataset/#lib_dataset-1","page":"Dataset","title":"Dataset","text":"","category":"section"},{"location":"lib/internals/dataset/#","page":"Dataset","title":"Dataset","text":"The dataset file contains the majority of the core code in CfGRIB.jl. It defines the key datatypes used throughout the package, as well as how data is read from the disk and how it gets interpreted.","category":"page"},{"location":"lib/internals/dataset/#","page":"Dataset","title":"Dataset","text":"","category":"page"},{"location":"lib/internals/dataset/#","page":"Dataset","title":"Dataset","text":"Modules = [CfGRIB]\nPages   = [\"dataset.jl\"]","category":"page"},{"location":"lib/internals/dataset/#","page":"Dataset","title":"Dataset","text":"Modules = [CfGRIB]\nPages   = [\"dataset.jl\"]","category":"page"},{"location":"lib/internals/dataset/#CfGRIB.DataSet","page":"Dataset","title":"CfGRIB.DataSet","text":"Summary\n\nstruct DataSet\n\nMap a GRIB file to the NetCDF Common Data Model with CF Conventions.\n\nFields\n\ndimensions::OrderedCollections.OrderedDict\nvariables::OrderedCollections.OrderedDict\nattributes::OrderedCollections.OrderedDict\nencoding::Dict\n\nConstructors\n\nDataSet(dimensions, variables, attributes, encoding)\nDataSet(dimensions, variables, attributes, encoding)\n\nDataSet(path; read_keys, kwargs...)\n\n\n\n\n\n","category":"type"},{"location":"workshops/intro/00-readme/#Introductory-Workshop-Notes-1","page":"Introductory Workshop Notes","title":"Introductory Workshop Notes","text":"","category":"section"},{"location":"workshops/intro/00-readme/#","page":"Introductory Workshop Notes","title":"Introductory Workshop Notes","text":"Some notes on what to do before running the notebooks in this directory","category":"page"},{"location":"workshops/intro/00-readme/#Install-Process-1","page":"Introductory Workshop Notes","title":"Install Process","text":"","category":"section"},{"location":"workshops/intro/00-readme/#Installing-Julia-1","page":"Introductory Workshop Notes","title":"Installing Julia","text":"","category":"section"},{"location":"workshops/intro/00-readme/#","page":"Introductory Workshop Notes","title":"Introductory Workshop Notes","text":"Julia can be installed from the julialang website.","category":"page"},{"location":"workshops/intro/00-readme/#Installing-cfgrib.jl-1","page":"Introductory Workshop Notes","title":"Installing cfgrib.jl","text":"","category":"section"},{"location":"workshops/intro/00-readme/#","page":"Introductory Workshop Notes","title":"Introductory Workshop Notes","text":"Packages in Julia are usually installed by entering package mode (press ] in the julia prompt on a newline) and simply running ] add https://github.com/ecmwf/cfgrib.jl, however as the aim is to dive a bit into the code it will be easier to install cfgrib.jl as a project instead.","category":"page"},{"location":"workshops/intro/00-readme/#","page":"Introductory Workshop Notes","title":"Introductory Workshop Notes","text":"To do this, you clone the project, cd into it, and then run instantiate, e.g:","category":"page"},{"location":"workshops/intro/00-readme/#","page":"Introductory Workshop Notes","title":"Introductory Workshop Notes","text":"> git clone https://github.com/ecmwf/cfgrib.jl\n> cd cfgrib.jl\n> julia\njulia > ]\n(@v1.4) pkg> activate .\n(@v1.4) pkg> instantiate","category":"page"},{"location":"workshops/intro/00-readme/#","page":"Introductory Workshop Notes","title":"Introductory Workshop Notes","text":"This would typically work, however there will likely be an error saying that the GRIB.jl package cannot be found. This is because it has not been added to the Julia package registry yet, you must first manually install it by running add https://github.com/weech/GRIB.jl while in package mode. Once it has finished, run instantiate again and cfgrib.jl will be installed.","category":"page"},{"location":"workshops/intro/00-readme/#Installing-a-Julia-Kernel-1","page":"Introductory Workshop Notes","title":"Installing a Julia Kernel","text":"","category":"section"},{"location":"workshops/intro/00-readme/#","page":"Introductory Workshop Notes","title":"Introductory Workshop Notes","text":"There are a few ways to set up IJulia as noted on the IJulia repository, the simplest install process is running:","category":"page"},{"location":"workshops/intro/00-readme/#","page":"Introductory Workshop Notes","title":"Introductory Workshop Notes","text":"> julia\njulia > ]\n(@v1.4) pkg> add IJulia\n(@v1.4) pkg> (backspace to exit pkg mode)\njulia > using IJulia","category":"page"},{"location":"workshops/intro/00-readme/#","page":"Introductory Workshop Notes","title":"Introductory Workshop Notes","text":"This will install the standard IJulia kernel which should automatically find and load the project in the parent directory of the notebook, enabling the correct environment for the notebooks to run in.","category":"page"},{"location":"workshops/intro/00-readme/#","page":"Introductory Workshop Notes","title":"Introductory Workshop Notes","text":"Now just start Jupyter as you normally would and open the notebooks in order.","category":"page"},{"location":"man/guide/#In-Depth-Guide-1","page":"Manual","title":"In Depth Guide","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"This is a start guide for how the internals of CfGRIB.jl work, targeted towards advanced users or those who want to work with the internals of the code.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"If you want a quick guide on how to use the package then check the Quick Start Guide","category":"page"},{"location":"man/guide/#Internals-1","page":"Manual","title":"Internals","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"The package internals are covered in the library section of the documentation in greater detail, however it is useful to have a vague sense of what is happening when you load a dataset.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"First, we load the package, and for convenience create a string pointing to our file path:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"using CfGRIB\n\nsample_data_dir = abspath(joinpath(dirname(pathof(CfGRIB)), \"..\", \"test\", \"sample-data\"))\n\ndemo_file_path = joinpath(sample_data_dir, \"era5-levels-members.grib\")","category":"page"},{"location":"man/guide/#FileIndex-1","page":"Manual","title":"FileIndex","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"Whenever you load a grib file, the first thing that happens is that the file index is read. The file index contains metadata which describes which messages contain what information inside the file. We can explore the index by manually creating a FileIndex object.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"First, we can look at the docstring for the FileIndex constructor by typing in ? at the REPL to enter help mode, then type in CfGRIB.FileIndex, press enter, and we get the docstring:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"help?> CfGRIB.FileIndex\n  Summary\n  ≡≡≡≡≡≡≡≡≡\n\n  mutable struct FileIndex\n\n  A mutable store for indices of a GRIB file\n\n  TODO: Should probably change this to a immutable struct\n\n  Fields\n  ≡≡≡≡≡≡≡≡\n\n    •    allowed_protocol_version::VersionNumber\n\n        Version number used when saving/hashing index files, should change if\n        the indexing structure changes breaking backwards-compatibility\n\n    •    grib_path::String\n\n        Path to the file the index belongs to\n\n    •    index_path::String\n\n        Path to the index cache file\n\n    •    index_keys::Array{String,1}\n\n        Array containing all of the index keys\n\n    •    offsets::Array{Pair{NamedTuple,Int64},1}\n\n        Array containing pairs of offsets[HeaderTuple(header_values)] => offset_field\n\n    •    message_lengths::Array{Int64,1}\n\n        Array containing the length of each message in the GRIB file\n\n    •    header_values::OrderedCollections.OrderedDict{String,Array}\n\n        Dictionary of all of the loaded header values in the GRIB file\n\n    •    filter_by_keys::Dict\n\n        Filters used when creating the file index\n\n  Constructors\n  ≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\n  FileIndex()\n\n  defined at dev/CfGRIB/src/indexing.jl:34\n  (https://github.com/ecmwf/cfgrib.jl/tree/5ced129d540ed9a1ff57da48c9b4f047b17d936d//src/indexing.jl#L34).\n\n  FileIndex(grib_path, index_keys)\n\n  defined at dev/CfGRIB/src/indexing.jl:38\n  (https://github.com/ecmwf/cfgrib.jl/tree/5ced129d540ed9a1ff57da48c9b4f047b17d936d//src/indexing.jl#L38).","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"The docstring is quite long, it explains the fields contained in the object, as well as giving a list of the constructors which can be used to create an instance of the object.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"We'll use the second constructor, which takes in a path to the file and a list of keys. First, we pick which keys we want to use. In this case we'll just use the ALL_KEYS constant:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"println(CfGRIB.ALL_KEYS)\n\nindex = CfGRIB.FileIndex(\n           demo_file_path,\n           CfGRIB.ALL_KEYS\n       );","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"From here you can explore fields contained in this object. Typically you will never interact with the FileIndex directly, as it's just used in the background to load the data.","category":"page"},{"location":"man/guide/#DataSet-1","page":"Manual","title":"DataSet","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"Once the FileIndex has been created, the next step is to use it to create a DataSet object. The DataSet is what what you use to access the stored data. The docstring says:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"help?> CfGRIB.DataSet\n  Summary\n  ≡≡≡≡≡≡≡≡≡\n\n  struct DataSet\n\n  Map a GRIB file to the NetCDF Common Data Model with CF Conventions.\n\n  Fields\n  ≡≡≡≡≡≡≡≡\n\n    •    dimensions::OrderedCollections.OrderedDict{String,Int64}\n\n        OrderedDict{String,Int} of $DIMENSION_NAME => $DIMENSION_LENGTH.\n\n    •    variables::OrderedCollections.OrderedDict{String,CfGRIB.Variable}\n\n        OrderedDict{String,CfGRIB.Variable} of $DIMENSION_NAME => $DIMENSION_VARIABLE, where the the variable is a CfGRIB.jl Variable.\n\n    •    attributes::OrderedCollections.OrderedDict{String,Any}\n\n        OrderedDict{String,Any} containing some metadata extracted from the file.\n\n    •    encoding::Dict{String,Any}\n\n        Dict{String,Any} containing metadata related to CfGRIB.jl, e.g. filter_by_keys\n\n  Constructors\n  ≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\n  DataSet(dimensions, variables, attributes, encoding)\n\n  defined at dev/CfGRIB/src/dataset.jl:127\n  (https://github.com/ecmwf/cfgrib.jl/tree/5ced129d540ed9a1ff57da48c9b4f047b17d936d//src/dataset.jl#L127).\n\n  DataSet(path; read_keys, kwargs...)\n\n  defined at dev/CfGRIB/src/dataset.jl:140\n  (https://github.com/ecmwf/cfgrib.jl/tree/5ced129d540ed9a1ff57da48c9b4f047b17d936d//src/dataset.jl#L140).","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"Here we see references to Variable, so we'll briefly explain those.","category":"page"},{"location":"man/guide/#Variable-1","page":"Manual","title":"Variable","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"A Variable is a basic struct in CfGRIB.jl which contains information for a variable read from a GRIB file:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"help?> CfGRIB.Variable\n  Summary\n  ≡≡≡≡≡≡≡≡≡\n\n  struct Variable\n\n  Struct describing a cfgrib variable\n\n  Fields\n  ≡≡≡≡≡≡≡≡\n\n    •    dimensions::Tuple{Vararg{String,N} where N}\n\n        Name of the dimension(s) contained in this variable\n\n    •    data::Union{CfGRIB.OnDiskArray, Number, Array}\n\n        Data contained in the variable, can point ot in-memory data or to a CfGRIB\n        OnDiskArray\n\n    •    attributes::Dict{String,Any}\n\n        Dictionary containing metadata for the variable, typically the units, the long name,\n        and the standard name\n\n  Constructors\n  ≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\n  Variable(dimensions, data, attributes)\n\n  defined at dev/CfGRIB/src/dataset.jl:108\n  (https://github.com/ecmwf/cfgrib.jl/tree/5ced129d540ed9a1ff57da48c9b4f047b17d936d//src/dataset.jl#L108).","category":"page"},{"location":"man/guide/#OnDiskArray-1","page":"Manual","title":"OnDiskArray","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"As explained above, Variables contain a data field, this data can either be in-memory data (Array, Number), or it could be an OnDiskArray. On disk arrays are, as the name hints, a way to represent data stored on the disk before that data is loaded.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"This is done do make it a bit easier to deal with large datasets, as the data is only lazily loaded in when the user attempts to read it. And then, only the requested data is stored in memory.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"help?> CfGRIB.OnDiskArray\n  Summary\n  ≡≡≡≡≡≡≡≡≡\n\n  struct OnDiskArray\n\n  Struct that contains metadata for an array, used to lazy-load the array from disk only when\n  requested\n\n  Fields\n  ≡≡≡≡≡≡≡≡\n\n    •    grib_path::String\n\n    •    size::Tuple\n\n    •    offsets::OrderedCollections.OrderedDict\n\n    •    message_lengths::Array{Int64,1}\n\n    •    missing_value::Any\n\n    •    geo_ndim::Int64\n\n    •    dtype::Type\n\n  Constructors\n  ≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\n  OnDiskArray(grib_path, size, offsets, message_lengths, missing_value, geo_ndim, dtype)\n\n  defined at dev/CfGRIB/src/dataset.jl:27\n  (https://github.com/ecmwf/cfgrib.jl/tree/5ced129d540ed9a1ff57da48c9b4f047b17d936d//src/dataset.jl#L27).","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"The OnDiskArray object contains enough information to fully describe the data stored on disk, and to allow for easy indexing into this data. A custom getindex method dispatches off of this type which opens the grib file at grib_path and reads only the relevant messages.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"For example, if a 3 dimensional array is described by OnDiskArray, and the user requests information with index [1, :, :], then only messages within that index are loaded from the grib file.","category":"page"},{"location":"man/guide/#DataSet-Constructors-1","page":"Manual","title":"DataSet Constructors","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"Now that the groundwork is laid down, lets look into how files are read and used in the end. The most basic option is calling DataSet with a string as a path, this will use the constructor defined at dev/CfGRIB/src/dataset.jl:140 (https://github.com/ecmwf/cfgrib.jl/tree/5ced129d540ed9a1ff57da48c9b4f047b17d936d//src/dataset.jl#L140).","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"As you can see this creates a FileIndex, and then returns:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"DataSet(build_dataset_components(\n    index;\n    errors=errors,\n    encode_cf=encode_cf,\n    squeeze=squeeze,\n    read_keys=read_keys,\n    time_dims=time_dims,\n)...)","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"The call to build_dataset_components returns the dimensions, variables, attributes, and encoding read from a file. These four variables are then passed to the other relevant constructor defined at dev/CfGRIB/src/dataset.jl:127 (https://github.com/ecmwf/cfgrib.jl/tree/5ced129d540ed9a1ff57da48c9b4f047b17d936d//src/dataset.jl#L127).","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"The constructor then returns a DataSet object.","category":"page"},{"location":"man/guide/#Getting-Data-from-a-DataSet-1","page":"Manual","title":"Getting Data from a DataSet","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"Onc you have a DataSet object, you probably want to access its data.","category":"page"},{"location":"man/guide/#Direct-Access-1","page":"Manual","title":"Direct Access","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"The most basic way to do this is to just access the variables directly. For example:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"dataset = CfGRIB.DataSet(demo_file_path);\n\ndataset.dimensions\n\ndataset.variables","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"From here you can check the Variable documentation to see what is stored in these. So, if we want to get the data for z:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"dataset.variables[\"z\"]\n\ndataset.variables[\"z\"].data\n\nconvert(Array, dataset.variables[\"z\"].data)[:, :, 1, 1, 1]","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"Since it's an OnDiskArray it has to be converted (which in this case just reads the data from disk) into an Array. Once that's done, it's just a standard array type which can be accessed.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"For a normal variable stored in memory this is a bit easier as the reading step does not have to be performed:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"dataset.variables[\"number\"]\n\ndataset.variables[\"number\"].data","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"Accessing all of the data this way would be extremely awkward, so we provide a number of multidimensional named-axis backends which make data access far easier.","category":"page"},{"location":"man/guide/#Using-Named-Dimensional-Backends-1","page":"Manual","title":"Using Named Dimensional Backends","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"The recommended way to use CfGRIB.jl is to use an array backend. More information about backends can be found on the Backends documentation page.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"If one of the backend dependencies is available you can convert to that backend data type with the convert function:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"using AxisArrays\n\ndimensional_dataset = convert(AxisArray, dataset)","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"This conversion to a backend will create an object for that specific backend, preserving all of the data that was present in our DataSet objects (e.g. the metadata will all be propagated through).","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"Current backend implementations have two limitations:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"No 'dataset' like support\nNo metadata support","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"These limitations mean that we have to create a wrapper struct which can hold the multidimensional array type from the backend, as well as some additional attributes.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"In the python xarray package, there are two basic types: a DataArray and a DataSet. The DataArray is a multidimensional array of a single variable, which contains information for that variable as well as information about the dimensions which enables useful indexing capabilities.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"The DataSet is a set of multiple DataArrays with common dimensions. This lets you have a DataArray containing pressure information with dimensions of, for example, time, latitude, longitude, and height; if you have another set of data with the same dimensions but for temperature then you can store both in a singe DataSet.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"The backends we currently use do not have this functionality, so instead we just wrap the two variables and allow for easy access to both.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"Additionally, our DataSet contains some more metadata (such as the attributes and encoding information), which also cannot be stored in the array backends, so we store that in the wrapper as well.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"To access the data you first access a single specific dataset and then index into it as per the docs for your chosen backend. For example, above we use AxisArrays as the backend, so:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"using AxisArrays\n\nz = dimensional_dataset.z;  # Looking at the `z` variable\n\nz[number=atvalue(0), isobaricInhPa=700..900, longitude=40..44]","category":"page"},{"location":"lib/internals/cfmessage/#","page":"CFMessage","title":"CFMessage","text":"Author = \"Robert Rosca\"","category":"page"},{"location":"lib/internals/cfmessage/#lib_cfmessage-1","page":"CFMessage","title":"CFMessage","text":"","category":"section"},{"location":"lib/internals/cfmessage/#","page":"CFMessage","title":"CFMessage","text":"CFMessage contains a number of utility functions for converting variables in a GRIB message to the values a user would expect to work with.","category":"page"},{"location":"lib/internals/cfmessage/#","page":"CFMessage","title":"CFMessage","text":"","category":"page"},{"location":"lib/internals/cfmessage/#","page":"CFMessage","title":"CFMessage","text":"Modules = [CfGRIB]\nPages   = [\"cfmessage.jl\"]","category":"page"},{"location":"lib/internals/cfmessage/#","page":"CFMessage","title":"CFMessage","text":"Modules = [CfGRIB]\nPages   = [\"cfmessage.jl\"]","category":"page"},{"location":"lib/internals/cfmessage/#CfGRIB.COMPUTED_KEYS","page":"CFMessage","title":"CfGRIB.COMPUTED_KEYS","text":"Dictionary which maps a key to a conversion method. The first function is the 'to' conversion, the second is 'from'.\n\nTODO: Actually applying the from_grib_step function results in different values to cfgrib.py, so step -> (from_grib_step, to_grib_step) is currently disabled.\n\nCurrently converts:\n\n    \"time\" => (from_grib_date_time, to_grib_date_time)\n\n    \"valid_time\" => (\n        message -> from_grib_date_time(message, date_key=\"validityDate\", time_key=\"validityTime\"),\n        message -> to_grib_date_time(message, date_key=\"validityDate\", time_key=\"validityTime\"),\n    )\n\n    \"verifying_time\" => (from_grib_month, m -> throw(ErrorException(\"Unimplemented\")))\n\n    \"indexing_time\" => (\n        message -> from_grib_date_time(message, date_key=\"indexingDate\", time_key=\"indexingTime\"),\n        message -> to_grib_date_time(message, date_key=\"indexingDate\", time_key=\"indexingTime\"),\n    )\n\nExample\n\nA GRIB message containing 20160501 as the date key and 0 as the time key would end up calling:\n\njulia> CfGRIB.COMPUTED_KEYS[\"time\"](20160501, 0)\n1462060800\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/cfmessage/#CfGRIB.DEFAULT_EPOCH","page":"CFMessage","title":"CfGRIB.DEFAULT_EPOCH","text":"Dates.DateTime\n\nDefault epoch used for from_ and to_ methods, set to 1970-01-01T00:00:00.\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/cfmessage/#CfGRIB.GRIB_STEP_UNITS_TO_SECONDS","page":"CFMessage","title":"CfGRIB.GRIB_STEP_UNITS_TO_SECONDS","text":"Array{Union{Missing, Int64},1}\n\nArray used to convert the grib step units to seconds. As Julia is 1-indexed, not 0 like Python, you should take care to correctly access the array, typically  just +1 to the step units before using it as an index.\n\nTaken from eccodes stepUnits.table.\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/cfmessage/#CfGRIB.build_valid_time","page":"CFMessage","title":"CfGRIB.build_valid_time","text":"Returns a pair of (dims, data) based on the type of input\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/cfmessage/#CfGRIB.build_valid_time-Tuple{Array{Int64,1},Array{Int64,1}}","page":"CFMessage","title":"CfGRIB.build_valid_time","text":"build_valid_time(time::Array{Int64,1}, step::Array{Int64,1}) -> Union{Tuple{Tuple{},Int64}, Tuple{Tuple{String,String},Array{Int64,2}}}\n\n\njulia> CfGRIB.build_valid_time([10, 10], [10, 10])\n((\"time\", \"step\"), [36010 36010; 36010 36010])\n\njulia> CfGRIB.build_valid_time([10], [10])\n((), 36010)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/cfmessage/#CfGRIB.build_valid_time-Tuple{Array{Int64,1},Int64}","page":"CFMessage","title":"CfGRIB.build_valid_time","text":"build_valid_time(time::Array{Int64,1}, step::Int64) -> Tuple{Tuple{String},Array{Int64,1}}\n\n\njulia> CfGRIB.build_valid_time([10], 10)\n((\"time\",), [36010])\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/cfmessage/#CfGRIB.build_valid_time-Tuple{Int64,Array{Int64,1}}","page":"CFMessage","title":"CfGRIB.build_valid_time","text":"build_valid_time(time::Int64, step::Array{Int64,1}) -> Tuple{Tuple{String},Array{Int64,1}}\n\n\njulia> CfGRIB.build_valid_time(1, [10])\n((\"step\",), [36001])\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/cfmessage/#CfGRIB.build_valid_time-Tuple{Int64,Int64}","page":"CFMessage","title":"CfGRIB.build_valid_time","text":"build_valid_time(time::Int64, step::Int64) -> Tuple{Tuple{},Int64}\n\n\njulia> CfGRIB.build_valid_time(10, 10)\n((), 36010)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/cfmessage/#CfGRIB.from_grib_date_time","page":"CFMessage","title":"CfGRIB.from_grib_date_time","text":"Returns the integer seconds from epoch to the given date and time.\n\nfrom_grib_date_time(date, time; epoch)\n\nfrom_grib_date_time(message; date_key, time_key, epoch)\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/cfmessage/#CfGRIB.from_grib_date_time-Tuple{GRIB.Message}","page":"CFMessage","title":"CfGRIB.from_grib_date_time","text":"from_grib_date_time(message::GRIB.Message; date_key, time_key, epoch) -> Union{Missing, Int64}\n\n\nPulls out the date and time from given keys and passes them to from_grib_date_time(::Int, ::Int)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/cfmessage/#CfGRIB.from_grib_date_time-Tuple{Int64,Int64}","page":"CFMessage","title":"CfGRIB.from_grib_date_time","text":"from_grib_date_time(date::Int64, time::Int64; epoch) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/cfmessage/#CfGRIB.from_grib_month","page":"CFMessage","title":"CfGRIB.from_grib_month","text":"from_grib_month(message::GRIB.Message) -> Union{Missing, Int64}\nfrom_grib_month(message::GRIB.Message, verifying_month_key::String) -> Union{Missing, Int64}\nfrom_grib_month(message::GRIB.Message, verifying_month_key::String, epoch::Dates.DateTime) -> Union{Missing, Int64}\n\n\nReturns the integer seconds from the epoch to the verifying month value in the GRIB message.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/cfmessage/#CfGRIB.from_grib_step","page":"CFMessage","title":"CfGRIB.from_grib_step","text":"from_grib_step(message::GRIB.Message) -> Float64\nfrom_grib_step(message::GRIB.Message, step_key::String) -> Float64\nfrom_grib_step(message::GRIB.Message, step_key::String, step_unit_key::String) -> Float64\n\n\nReturns the step_key value in hours.\n\nUses GRIB_STEP_UNITS_TO_SECONDS to convert the step values to seconds, then divides by 3600.0 to get hours.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/cfmessage/#CfGRIB.read_message-Tuple{GRIB.Message,String}","page":"CFMessage","title":"CfGRIB.read_message","text":"read_message(message::GRIB.Message, key::String) -> Any\n\n\nReads a specific key from a GRIB.jl message. Attempts to convert the raw value associated with that key using the COMPUTED_KEYS mapping to from_grib_* functions.\n\n\n\n\n\n","category":"method"},{"location":"#","page":"Home","title":"Home","text":"Modules = [CfGRIB]\nPages   = [\"CfGRIB.jl\"]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [CfGRIB]\nPages   = [\"CfGRIB.jl\"]","category":"page"},{"location":"#CfGRIB.CfGRIB","page":"Home","title":"CfGRIB.CfGRIB","text":"CfGRIB.jl\n\n(Image: lifecycle) (Image: Build Status) (Image: Codecov) (Image: latest release) (Image: Apache 2 license) (Image: )\n\nDescription\n\nCfGRIB.jl is a julia interface to map GRIB files to the Unidata's Common Data Model v4 following the CF Conventions.\n\nThis package is based on the python implementation in cfgrib.py and closely follows the approaches of that package, but in Julia instead. Parity tests are automatically performed between the two to ensure that the data returned by the Julia version is equivalent to that from Python.\n\nIn Python xarray has come out to be a standard way to implement named arrays, however as Julia is a much younger language no stable array interface has been adopted by the community yet, so the approach here is more flexible and allows for multiple array backends to be used.\n\nLow level access and decoding is performed by calling GRIB.jl which itself calls the ECMWF ecCodes library.\n\nInstallation\n\nThe package is currently under heavy development so it has not been added to the Julia package registry yet. To install the package first clone this repository:\n\ngit clone https://github.com/robertrosca/CfGRIB.jl/\ncd CfGRIB.jl\n\nThen start Julia, enter the pkg mode, activate the project (projects are similar to python venv's), install the GRIB.jl package (as it is also not on the registry), and then finally you can instantiate CfGRIB.jl to get the rest of the dependencies:\n\nactivate .\nadd https://github.com/weech/GRIB.jl\ninstantiate\n\nFinally exit pkg mode by pressing backspace, and use the package as usual:\n\nusing CfGRIB\n\n\n\n\n\n","category":"module"},{"location":"lib/internals/backends/#","page":"Backends","title":"Backends","text":"Author = \"Robert Rosca\"","category":"page"},{"location":"lib/internals/backends/#lib_backends-1","page":"Backends","title":"Backends","text":"","category":"section"},{"location":"lib/internals/backends/#","page":"Backends","title":"Backends","text":"CfGRIB.jl has a flexible backend system built in to allow for multiple ways to represent multidimensional data with named dimensions.","category":"page"},{"location":"lib/internals/backends/#","page":"Backends","title":"Backends","text":"Backends are loaded in dynamically based on what packages the user has available, currently there are two built-in backends, one is based on DimensionalData.jl and the other uses AxisArrays.","category":"page"},{"location":"lib/internals/backends/#","page":"Backends","title":"Backends","text":"Additionally, FileIO.jl integration is prepared for each of the backends so that users utilising FileIO can use its smart load functions which will load the file via CfGRIB.jl when the correct file extension and magic numbers are present.","category":"page"},{"location":"lib/internals/backends/#","page":"Backends","title":"Backends","text":"","category":"page"},{"location":"lib/internals/backends/#","page":"Backends","title":"Backends","text":"Modules = [CfGRIB]\nPages   = [\"backends.jl\"]","category":"page"},{"location":"lib/internals/backends/#","page":"Backends","title":"Backends","text":"Modules = [CfGRIB]\nPages   = [\"backends.jl\"]","category":"page"},{"location":"lib/internals/backends/#CfGRIB.ArrayWrapper","page":"Backends","title":"CfGRIB.ArrayWrapper","text":"Summary\n\nabstract type ArrayWrapper <: CfGRIB.Backend\n\nAbstract type for backends which also wrap data types provided by external packages, instead of just providing a 'vanilla' implementation of the data type.\n\nPython's xarray has two fundamental data structures, a DataArray which holds the data for a single multi-dimensional variable and its coordinates, as well as a Dataset which holds multiple DataArrays that (typically) share the same coordinates.\n\nSee also\n\nAxisArrayWrapper, DimensionalArrayWrapper\n\nFields\n\nConstructors\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/backends/#CfGRIB.Backend","page":"Backends","title":"CfGRIB.Backend","text":"Summary\n\nabstract type Backend\n\nBackends are wrappers around named array data types, contain information on the dimensions, attributes, and encoding of the data, as well as the datasets themselves.\n\nSee also\n\nAxisArrayWrapper, DimensionalArrayWrapper\n\nFields\n\nConstructors\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/backends/#","page":"Backends","title":"Backends","text":"","category":"page"},{"location":"lib/internals/backends/#","page":"Backends","title":"Backends","text":"Modules = [CfGRIB]\nPages   = [\"backends/axisarrays.jl\", \"backends/dimensionaldata.jl\"]","category":"page"},{"location":"lib/internals/backends/#","page":"Backends","title":"Backends","text":"Modules = [CfGRIB]\nPages   = [\"backends/axisarrays.jl\", \"backends/dimensionaldata.jl\"]","category":"page"},{"location":"lib/internals/backends/#CfGRIB.AxisArrayWrapper","page":"Backends","title":"CfGRIB.AxisArrayWrapper","text":"Summary\n\nstruct AxisArrayWrapper <: CfGRIB.ArrayWrapper\n\nAxisArrays provides the equivalent of an xarray DataArray, this wrapper adds the functionality of an xarray DataSet by containing multiple AxisArrays.\n\nObject should be created by calling the relevant convert(AxisArrayWrapper, dataset::DataSet) method on a DataSet.\n\nSee also\n\nBackend, ArrayWrapper\n\nFields\n\ndimensions::OrderedCollections.OrderedDict\nDictionary of DimensionName::String => DimensionLength::Int\ndatasets::NamedTuple\nNamed tuple of DatasetName::Symbol => Dataset::AxisArray\nattributes::OrderedCollections.OrderedDict\nDictionary of AttributeName::String => AttributeValue::Any\nencoding::Dict\nDictionary containing encoding information (usually source, filter_by_keys, and ecode_cf)\n\nConstructors\n\nAxisArrayWrapper(dimensions, datasets, attributes, encoding)\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/backends/#CfGRIB.DimensionalArrayWrapper","page":"Backends","title":"CfGRIB.DimensionalArrayWrapper","text":"Summary\n\nstruct DimensionalArrayWrapper <: CfGRIB.ArrayWrapper\n\nDimensionalData provides the equivalent of an xarray DataArray, this wrapper adds the functionality of an xarray DataSet by containing multiple DimensionalArrays.\n\nObject should be created by calling the relevant convert(DimensionalArrayWrapper, dataset::DataSet) method on a DataSet.\n\nSee also\n\nBackend, ArrayWrapper\n\nFields\n\ndimensions::OrderedCollections.OrderedDict\nDictionary of DimensionName::String => DimensionLength::Int\ndatasets::NamedTuple\nNamed tuple of DatasetName::Symbol => Dataset::DimensionalArray\nattributes::OrderedCollections.OrderedDict\nDictionary of AttributeName::String => AttributeValue::Any\nencoding::Dict\nDictionary containing encoding information (usually source, filter_by_keys, and ecode_cf)\n\nConstructors\n\nDimensionalArrayWrapper(dimensions, datasets, attributes, encoding)\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/constants/#","page":"Constants","title":"Constants","text":"Author = \"Robert Rosca\"","category":"page"},{"location":"lib/internals/constants/#lib_constants-1","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"lib/internals/constants/#","page":"Constants","title":"Constants","text":"Constants contains a number of constant arrays and dictionaries used to define which keys and attributes are expected to be present in a GRIB message, how to map grid types to correct representations of the data, etc...","category":"page"},{"location":"lib/internals/constants/#","page":"Constants","title":"Constants","text":"These constants are shown in the documentation for ease of use and reference purposes.","category":"page"},{"location":"lib/internals/constants/#","page":"Constants","title":"Constants","text":"","category":"page"},{"location":"lib/internals/constants/#","page":"Constants","title":"Constants","text":"Modules = [CfGRIB]\nPages   = [\"constants.jl\"]","category":"page"},{"location":"lib/internals/constants/#","page":"Constants","title":"Constants","text":"Modules = [CfGRIB]\nPages   = [\"constants.jl\"]","category":"page"},{"location":"lib/internals/constants/#CfGRIB.ALL_HEADER_DIMS","page":"Constants","title":"CfGRIB.ALL_HEADER_DIMS","text":"[\"number\", \"level\", \"dataDate\", \"dataTime\", \"endStep\", \"time\", \"step\", \"valid_time\", \"verifying_time\", \"indexing_time\", \"forecastMonth\", \"directionNumber\", \"frequencyNumber\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/constants/#CfGRIB.ALL_KEYS","page":"Constants","title":"CfGRIB.ALL_KEYS","text":"[\"DxInMetres\", \"DyInMetres\", \"J\", \"K\", \"LaDInDegrees\", \"Latin1InDegrees\", \"Latin2InDegrees\", \"LoVInDegrees\", \"M\", \"N\", \"NV\", \"Nx\", \"Ny\", \"angleOfRotationInDegrees\", \"centre\", \"centreDescription\", \"cfName\", \"cfVarName\", \"dataDate\", \"dataTime\", \"dataType\", \"directionNumber\", \"edition\", \"endStep\", \"forecastMonth\", \"frequencyNumber\", \"gridDefinitionDescription\", \"gridType\", \"iDirectionIncrementInDegrees\", \"iScansNegatively\", \"indexing_time\", \"jDirectionIncrementInDegrees\", \"jPointsAreConsecutive\", \"jScansPositively\", \"latitudeOfFirstGridPointInDegrees\", \"latitudeOfLastGridPointInDegrees\", \"latitudeOfSouthernPoleInDegrees\", \"level\", \"longitudeOfFirstGridPointInDegrees\", \"longitudeOfLastGridPointInDegrees\", \"longitudeOfSouthernPoleInDegrees\", \"missingValue\", \"name\", \"number\", \"numberOfDirections\", \"numberOfFrequencies\", \"numberOfPoints\", \"paramId\", \"pl\", \"shortName\", \"step\", \"stepType\", \"stepUnits\", \"subCentre\", \"time\", \"totalNumber\", \"typeOfLevel\", \"units\", \"valid_time\", \"verifying_time\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/constants/#CfGRIB.ALL_REF_TIME_KEYS","page":"Constants","title":"CfGRIB.ALL_REF_TIME_KEYS","text":"[\"time\", \"step\", \"valid_time\", \"verifying_time\", \"indexing_time\", \"forecastMonth\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/constants/#CfGRIB.COORD_ATTRS","page":"Constants","title":"CfGRIB.COORD_ATTRS","text":"Dict(\"number\" => Dict(\"units\" => \"1\",\"long_name\" => \"ensemble member numerical id\",\"standard_name\" => \"realization\"),\"time\" => Dict(\"units\" => \"seconds since 1970-01-01T00:00:00\",\"calendar\" => \"proleptic_gregorian\",\"long_name\" => \"initial time of forecast\",\"standard_name\" => \"forecast_reference_time\"),\"depthBelowLand\" => Dict(\"units\" => \"m\",\"long_name\" => \"soil depth\",\"standard_name\" => \"depth\",\"positive\" => \"down\"),\"hybrid\" => Dict(\"units\" => \"1\",\"long_name\" => \"hybrid level\",\"standard_name\" => \"atmosphere_hybrid_sigma_pressure_coordinate\",\"positive\" => \"down\"),\"depthBelowLandLayer\" => Dict(\"units\" => \"m\",\"long_name\" => \"soil depth\",\"standard_name\" => \"depth\",\"positive\" => \"down\"),\"isobaricLayer\" => Dict(\"units\" => \"Pa\",\"long_name\" => \"pressure\",\"standard_name\" => \"air_pressure\",\"positive\" => \"down\"),\"step\" => Dict(\"units\" => \"hours\",\"long_name\" => \"time since forecast_reference_time\",\"standard_name\" => \"forecast_period\"),\"isobaricInhPa\" => Dict(\"units\" => \"hPa\",\"stored_direction\" => \"decreasing\",\"long_name\" => \"pressure\",\"standard_name\" => \"air_pressure\",\"positive\" => \"down\"),\"isobaricInPa\" => Dict(\"units\" => \"Pa\",\"stored_direction\" => \"decreasing\",\"long_name\" => \"pressure\",\"standard_name\" => \"air_pressure\",\"positive\" => \"down\"),\"valid_time\" => Dict(\"units\" => \"seconds since 1970-01-01T00:00:00\",\"calendar\" => \"proleptic_gregorian\",\"long_name\" => \"time\",\"standard_name\" => \"time\"),\"indexing_time\" => Dict(\"units\" => \"seconds since 1970-01-01T00:00:00\",\"calendar\" => \"proleptic_gregorian\",\"long_name\" => \"nominal initial time of forecast\",\"standard_name\" => \"forecast_reference_time\"),\"heightAboveGround\" => Dict(\"units\" => \"m\",\"long_name\" => \"height above the surface\",\"standard_name\" => \"height\",\"positive\" => \"up\"),\"latitude\" => Dict(\"units\" => \"degrees_north\",\"long_name\" => \"latitude\",\"standard_name\" => \"latitude\"),\"longitude\" => Dict(\"units\" => \"degrees_east\",\"long_name\" => \"longitude\",\"standard_name\" => \"longitude\"),\"verifying_time\" => Dict(\"units\" => \"seconds since 1970-01-01T00:00:00\",\"calendar\" => \"proleptic_gregorian\",\"long_name\" => \"time\",\"standard_name\" => \"time\"))\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/constants/#CfGRIB.DATA_ATTRIBUTES_KEYS","page":"Constants","title":"CfGRIB.DATA_ATTRIBUTES_KEYS","text":"[\"paramId\", \"shortName\", \"units\", \"name\", \"cfName\", \"cfVarName\", \"dataType\", \"missingValue\", \"numberOfPoints\", \"totalNumber\", \"numberOfDirections\", \"numberOfFrequencies\", \"typeOfLevel\", \"NV\", \"stepUnits\", \"stepType\", \"gridType\", \"gridDefinitionDescription\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/constants/#CfGRIB.DATA_TIME_KEYS","page":"Constants","title":"CfGRIB.DATA_TIME_KEYS","text":"[\"dataDate\", \"dataTime\", \"endStep\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/constants/#CfGRIB.ENSEMBLE_KEYS","page":"Constants","title":"CfGRIB.ENSEMBLE_KEYS","text":"[\"number\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/constants/#CfGRIB.GLOBAL_ATTRIBUTES_KEYS","page":"Constants","title":"CfGRIB.GLOBAL_ATTRIBUTES_KEYS","text":"[\"edition\", \"centre\", \"centreDescription\", \"subCentre\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/constants/#CfGRIB.GRID_TYPES_2D_NON_DIMENSION_COORDS","page":"Constants","title":"CfGRIB.GRID_TYPES_2D_NON_DIMENSION_COORDS","text":"[\"rotated_ll\", \"rotated_gg\", \"lambert\", \"albers\", \"polar_stereographic\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/constants/#CfGRIB.GRID_TYPES_DIMENSION_COORDS","page":"Constants","title":"CfGRIB.GRID_TYPES_DIMENSION_COORDS","text":"[\"regular_ll\", \"regular_gg\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/constants/#CfGRIB.GRID_TYPE_KEYS","page":"Constants","title":"CfGRIB.GRID_TYPE_KEYS","text":"[\"Nx\", \"Ny\", \"angleOfRotationInDegrees\", \"iDirectionIncrementInDegrees\", \"iScansNegatively\", \"jPointsAreConsecutive\", \"jScansPositively\", \"latitudeOfFirstGridPointInDegrees\", \"latitudeOfLastGridPointInDegrees\", \"latitudeOfSouthernPoleInDegrees\", \"longitudeOfFirstGridPointInDegrees\", \"longitudeOfLastGridPointInDegrees\", \"longitudeOfSouthernPoleInDegrees\", \"N\", \"M\", \"K\", \"J\", \"jDirectionIncrementInDegrees\", \"LaDInDegrees\", \"LoVInDegrees\", \"DyInMetres\", \"DxInMetres\", \"Latin2InDegrees\", \"Latin1InDegrees\", \"pl\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/constants/#CfGRIB.GRID_TYPE_MAP","page":"Constants","title":"CfGRIB.GRID_TYPE_MAP","text":"Dict(\"rotated_gg\" => [\"Nx\", \"Ny\", \"angleOfRotationInDegrees\", \"iDirectionIncrementInDegrees\", \"iScansNegatively\", \"jPointsAreConsecutive\", \"jScansPositively\", \"latitudeOfFirstGridPointInDegrees\", \"latitudeOfLastGridPointInDegrees\", \"latitudeOfSouthernPoleInDegrees\", \"longitudeOfFirstGridPointInDegrees\", \"longitudeOfLastGridPointInDegrees\", \"longitudeOfSouthernPoleInDegrees\", \"N\"],\"regular_gg\" => [\"Nx\", \"iDirectionIncrementInDegrees\", \"iScansNegatively\", \"longitudeOfFirstGridPointInDegrees\", \"longitudeOfLastGridPointInDegrees\", \"N\", \"Ny\"],\"sh\" => [\"M\", \"K\", \"J\"],\"regular_ll\" => [\"Nx\", \"iDirectionIncrementInDegrees\", \"iScansNegatively\", \"longitudeOfFirstGridPointInDegrees\", \"longitudeOfLastGridPointInDegrees\", \"Ny\", \"jDirectionIncrementInDegrees\", \"jPointsAreConsecutive\", \"jScansPositively\", \"latitudeOfFirstGridPointInDegrees\", \"latitudeOfLastGridPointInDegrees\"],\"lambert\" => [\"LaDInDegrees\", \"LoVInDegrees\", \"iScansNegatively\", \"jPointsAreConsecutive\", \"jScansPositively\", \"latitudeOfFirstGridPointInDegrees\", \"latitudeOfSouthernPoleInDegrees\", \"longitudeOfFirstGridPointInDegrees\", \"longitudeOfSouthernPoleInDegrees\", \"DyInMetres\", \"DxInMetres\", \"Latin2InDegrees\", \"Latin1InDegrees\", \"Ny\", \"Nx\"],\"reduced_gg\" => [\"N\", \"pl\"],\"rotated_ll\" => [\"Nx\", \"Ny\", \"angleOfRotationInDegrees\", \"iDirectionIncrementInDegrees\", \"iScansNegatively\", \"jDirectionIncrementInDegrees\", \"jPointsAreConsecutive\", \"jScansPositively\", \"latitudeOfFirstGridPointInDegrees\", \"latitudeOfLastGridPointInDegrees\", \"latitudeOfSouthernPoleInDegrees\", \"longitudeOfFirstGridPointInDegrees\", \"longitudeOfLastGridPointInDegrees\", \"longitudeOfSouthernPoleInDegrees\"],\"reduced_ll\" => [\"Ny\", \"jDirectionIncrementInDegrees\", \"jPointsAreConsecutive\", \"jScansPositively\", \"latitudeOfFirstGridPointInDegrees\", \"latitudeOfLastGridPointInDegrees\"])\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/constants/#CfGRIB.SPECTRA_KEYS","page":"Constants","title":"CfGRIB.SPECTRA_KEYS","text":"[\"directionNumber\", \"frequencyNumber\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/constants/#CfGRIB.VERTICAL_KEYS","page":"Constants","title":"CfGRIB.VERTICAL_KEYS","text":"[\"level\"]\n\n\n\n\n\n","category":"constant"}]
}
