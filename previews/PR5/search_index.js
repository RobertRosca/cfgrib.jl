var documenterSearchIndex = {"docs":
[{"location":"lib/cfmessage/#","page":"CFMessage","title":"CFMessage","text":"Author = \"Robert Rosca\"","category":"page"},{"location":"lib/cfmessage/#lib_cfmessage-1","page":"CFMessage","title":"CFMessage","text":"","category":"section"},{"location":"lib/cfmessage/#","page":"CFMessage","title":"CFMessage","text":"CFMessage contains a number of utility functions for converting variables in a GRIB message to the values a user would expect to work with.","category":"page"},{"location":"lib/cfmessage/#","page":"CFMessage","title":"CFMessage","text":"","category":"page"},{"location":"lib/cfmessage/#","page":"CFMessage","title":"CFMessage","text":"Modules = [CfGRIB]\nPages   = [\"cfmessage.jl\"]","category":"page"},{"location":"lib/cfmessage/#","page":"CFMessage","title":"CFMessage","text":"Modules = [CfGRIB]\nPages   = [\"cfmessage.jl\"]","category":"page"},{"location":"lib/cfmessage/#CfGRIB.COMPUTED_KEYS","page":"CFMessage","title":"CfGRIB.COMPUTED_KEYS","text":"Dictionary which maps a key to a conversion method. The first function is the 'to' conversion, the second is 'from'.\n\nTODO: Actually applying the from_grib_step function results in different values to cfgrib.py, so step -> (from_grib_step, to_grib_step) is currently disabled.\n\nCurrently converts:\n\n    \"time\" => (from_grib_date_time, to_grib_date_time)\n\n    \"valid_time\" => (\n        message -> from_grib_date_time(message, date_key=\"validityDate\", time_key=\"validityTime\"),\n        message -> to_grib_date_time(message, date_key=\"validityDate\", time_key=\"validityTime\"),\n    )\n\n    \"verifying_time\" => (from_grib_month, m -> throw(ErrorException(\"Unimplemented\")))\n\n    \"indexing_time\" => (\n        message -> from_grib_date_time(message, date_key=\"indexingDate\", time_key=\"indexingTime\"),\n        message -> to_grib_date_time(message, date_key=\"indexingDate\", time_key=\"indexingTime\"),\n    )\n\nExample\n\nA GRIB message containing 20160501 as the date key and 0 as the time key would end up calling:\n\njulia> CfGRIB.COMPUTED_KEYS[\"time\"](20160501, 0)\n1462060800\n\n\n\n\n\n","category":"constant"},{"location":"lib/cfmessage/#CfGRIB.DEFAULT_EPOCH","page":"CFMessage","title":"CfGRIB.DEFAULT_EPOCH","text":"Dates.DateTime\n\nDefault epoch used for from_ and to_ methods, set to 1970-01-01T00:00:00.\n\n\n\n\n\n","category":"constant"},{"location":"lib/cfmessage/#CfGRIB.GRIB_STEP_UNITS_TO_SECONDS","page":"CFMessage","title":"CfGRIB.GRIB_STEP_UNITS_TO_SECONDS","text":"Array{Union{Missing, Int64},1}\n\nArray used to convert the grib step units to seconds. As Julia is 1-indexed, not 0 like Python, you should take care to correctly access the array, typically  just +1 to the step units before using it as an index.\n\nTaken from eccodes stepUnits.table.\n\n\n\n\n\n","category":"constant"},{"location":"lib/cfmessage/#CfGRIB.build_valid_time","page":"CFMessage","title":"CfGRIB.build_valid_time","text":"Returns a pair of (dims, data) based on the type of input\n\n\n\n\n\n","category":"function"},{"location":"lib/cfmessage/#CfGRIB.build_valid_time-Tuple{Array{Int64,1},Array{Int64,1}}","page":"CFMessage","title":"CfGRIB.build_valid_time","text":"build_valid_time(time::Array{Int64,1}, step::Array{Int64,1}) -> Union{Tuple{Tuple{},Int64}, Tuple{Tuple{String,String},Array{Int64,2}}}\n\n\njulia> CfGRIB.build_valid_time([10, 10], [10, 10])\n((\"time\", \"step\"), [36010 36010; 36010 36010])\n\njulia> CfGRIB.build_valid_time([10], [10])\n((), 36010)\n\n\n\n\n\n","category":"method"},{"location":"lib/cfmessage/#CfGRIB.build_valid_time-Tuple{Array{Int64,1},Int64}","page":"CFMessage","title":"CfGRIB.build_valid_time","text":"build_valid_time(time::Array{Int64,1}, step::Int64) -> Tuple{Tuple{String},Array{Int64,1}}\n\n\njulia> CfGRIB.build_valid_time([10], 10)\n((\"time\",), [36010])\n\n\n\n\n\n","category":"method"},{"location":"lib/cfmessage/#CfGRIB.build_valid_time-Tuple{Int64,Array{Int64,1}}","page":"CFMessage","title":"CfGRIB.build_valid_time","text":"build_valid_time(time::Int64, step::Array{Int64,1}) -> Tuple{Tuple{String},Array{Int64,1}}\n\n\njulia> CfGRIB.build_valid_time(1, [10])\n((\"step\",), [36001])\n\n\n\n\n\n","category":"method"},{"location":"lib/cfmessage/#CfGRIB.build_valid_time-Tuple{Int64,Int64}","page":"CFMessage","title":"CfGRIB.build_valid_time","text":"build_valid_time(time::Int64, step::Int64) -> Tuple{Tuple{},Int64}\n\n\njulia> CfGRIB.build_valid_time(10, 10)\n((), 36010)\n\n\n\n\n\n","category":"method"},{"location":"lib/cfmessage/#CfGRIB.from_grib_date_time","page":"CFMessage","title":"CfGRIB.from_grib_date_time","text":"Returns the integer seconds from epoch to the given date and time.\n\nfrom_grib_date_time(date, time; epoch)\n\ndefined at /home/runner/work/cfgrib.jl/cfgrib.jl/src/cfmessage.jl:52.\n\nfrom_grib_date_time(message; date_key, time_key, epoch)\n\ndefined at /home/runner/work/cfgrib.jl/cfgrib.jl/src/cfmessage.jl:73.\n\n\n\n\n\n","category":"function"},{"location":"lib/cfmessage/#CfGRIB.from_grib_date_time-Tuple{GRIB.Message}","page":"CFMessage","title":"CfGRIB.from_grib_date_time","text":"from_grib_date_time(message::GRIB.Message; date_key, time_key, epoch) -> Union{Missing, Int64}\n\n\nPulls out the date and time from given keys and passes them to from_grib_date_time(::Int, ::Int)\n\n\n\n\n\n","category":"method"},{"location":"lib/cfmessage/#CfGRIB.from_grib_date_time-Tuple{Int64,Int64}","page":"CFMessage","title":"CfGRIB.from_grib_date_time","text":"from_grib_date_time(date::Int64, time::Int64; epoch) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"lib/cfmessage/#CfGRIB.from_grib_month","page":"CFMessage","title":"CfGRIB.from_grib_month","text":"from_grib_month(message::GRIB.Message) -> Union{Missing, Int64}\nfrom_grib_month(message::GRIB.Message, verifying_month_key::String) -> Union{Missing, Int64}\nfrom_grib_month(message::GRIB.Message, verifying_month_key::String, epoch::Dates.DateTime) -> Union{Missing, Int64}\n\n\nReturns the integer seconds from the epoch to the verifying month value in the GRIB message.\n\n\n\n\n\n","category":"function"},{"location":"lib/cfmessage/#CfGRIB.from_grib_step","page":"CFMessage","title":"CfGRIB.from_grib_step","text":"from_grib_step(message::GRIB.Message) -> Float64\nfrom_grib_step(message::GRIB.Message, step_key::String) -> Float64\nfrom_grib_step(message::GRIB.Message, step_key::String, step_unit_key::String) -> Float64\n\n\nReturns the step_key value in hours.\n\nUses GRIB_STEP_UNITS_TO_SECONDS to convert the step values to seconds, then divides by 3600.0 to get hours.\n\n\n\n\n\n","category":"function"},{"location":"lib/cfmessage/#CfGRIB.read_message-Tuple{GRIB.Message,String}","page":"CFMessage","title":"CfGRIB.read_message","text":"read_message(message::GRIB.Message, key::String) -> Any\n\n\nReads a specific key from a GRIB.jl message. Attempts to convert the raw value associated with that key using the COMPUTED_KEYS mapping to from_grib_* functions.\n\n\n\n\n\n","category":"method"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Author = \"Robert Rosca\"","category":"page"},{"location":"lib/indexing/#lib_indexing-1","page":"Indexing","title":"Indexing","text":"","category":"section"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"GRIB.jl is by CfGRIB to read the GRIB files, GRIB.jl provides its own ways to create, read, and filter an index, however cfgrib.py uses a different approach to indexing. So, CfGRIB.jl, being based on the python implementation, recreates the python approach instead of integrating with the GRIB.jl indexing approach.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"The indexing file defines the FileIndex type, as well as the constructors for that type.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Modules = [CfGRIB]\nPages   = [\"indexing.jl\"]","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Modules = [CfGRIB]\nPages   = [\"indexing.jl\"]","category":"page"},{"location":"lib/indexing/#CfGRIB.FileIndex","page":"Indexing","title":"CfGRIB.FileIndex","text":"Summary\n\nmutable struct FileIndex\n\nA mutable store for indices of a GRIB file\n\nTODO: Should probably change this to a immutable struct\n\nFields\n\nallowed_protocol_version::VersionNumber\nVersion number used when saving/hashing index files, should change if the indexing structure changes breaking backwards-compatibility\ngrib_path::String\nPath to the file the index belongs to\nindex_path::String\nPath to the index cache file\nindex_keys::Array{String,1}\nArray containing all of the index keys\noffsets::Array{Pair{NamedTuple,Int64},1}\nArray containing pairs of offsets[HeaderTuple(header_values)] => offset_field\nmessage_lengths::Array{Int64,1}\nArray containing the length of each message in the GRIB file\nheader_values::OrderedCollections.OrderedDict{String,Array}\nDictionary of all of the loaded header values in the GRIB file\nfilter_by_keys::Dict\nFilters used when creating the file index\n\nConstructors\n\nFileIndex()\n\ndefined at /home/runner/work/cfgrib.jl/cfgrib.jl/src/indexing.jl:34.\n\nFileIndex(grib_path, index_keys; filter_by_keys)\n\ndefined at /home/runner/work/cfgrib.jl/cfgrib.jl/src/indexing.jl:42.\n\n\n\n\n\n","category":"type"},{"location":"lib/constants/#","page":"Constants","title":"Constants","text":"Author = \"Robert Rosca\"","category":"page"},{"location":"lib/constants/#lib_constants-1","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"lib/constants/#","page":"Constants","title":"Constants","text":"Constants contains a number of constant arrays and dictionaries used to define which keys and attributes are expected to be present in a GRIB message, how to map grid types to correct representations of the data, etc...","category":"page"},{"location":"lib/constants/#","page":"Constants","title":"Constants","text":"These constants are shown in the documentation for ease of use and reference purposes.","category":"page"},{"location":"lib/constants/#","page":"Constants","title":"Constants","text":"","category":"page"},{"location":"lib/constants/#","page":"Constants","title":"Constants","text":"Modules = [CfGRIB]\nPages   = [\"constants.jl\"]","category":"page"},{"location":"lib/constants/#","page":"Constants","title":"Constants","text":"Modules = [CfGRIB]\nPages   = [\"constants.jl\"]","category":"page"},{"location":"lib/constants/#CfGRIB.ALL_HEADER_DIMS","page":"Constants","title":"CfGRIB.ALL_HEADER_DIMS","text":"[\"number\", \"level\", \"dataDate\", \"dataTime\", \"endStep\", \"time\", \"step\", \"valid_time\", \"verifying_time\", \"indexing_time\", \"forecastMonth\", \"directionNumber\", \"frequencyNumber\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/constants/#CfGRIB.ALL_KEYS","page":"Constants","title":"CfGRIB.ALL_KEYS","text":"[\"DxInMetres\", \"DyInMetres\", \"J\", \"K\", \"LaDInDegrees\", \"Latin1InDegrees\", \"Latin2InDegrees\", \"LoVInDegrees\", \"M\", \"N\", \"NV\", \"Nx\", \"Ny\", \"angleOfRotationInDegrees\", \"centre\", \"centreDescription\", \"cfName\", \"cfVarName\", \"dataDate\", \"dataTime\", \"dataType\", \"directionNumber\", \"edition\", \"endStep\", \"forecastMonth\", \"frequencyNumber\", \"gridDefinitionDescription\", \"gridType\", \"iDirectionIncrementInDegrees\", \"iScansNegatively\", \"indexing_time\", \"jDirectionIncrementInDegrees\", \"jPointsAreConsecutive\", \"jScansPositively\", \"latitudeOfFirstGridPointInDegrees\", \"latitudeOfLastGridPointInDegrees\", \"latitudeOfSouthernPoleInDegrees\", \"level\", \"longitudeOfFirstGridPointInDegrees\", \"longitudeOfLastGridPointInDegrees\", \"longitudeOfSouthernPoleInDegrees\", \"missingValue\", \"name\", \"number\", \"numberOfDirections\", \"numberOfFrequencies\", \"numberOfPoints\", \"paramId\", \"pl\", \"shortName\", \"step\", \"stepType\", \"stepUnits\", \"subCentre\", \"time\", \"totalNumber\", \"typeOfLevel\", \"units\", \"valid_time\", \"verifying_time\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/constants/#CfGRIB.ALL_REF_TIME_KEYS","page":"Constants","title":"CfGRIB.ALL_REF_TIME_KEYS","text":"[\"time\", \"step\", \"valid_time\", \"verifying_time\", \"indexing_time\", \"forecastMonth\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/constants/#CfGRIB.COORD_ATTRS","page":"Constants","title":"CfGRIB.COORD_ATTRS","text":"Dict(\"number\" => Dict(\"units\" => \"1\",\"long_name\" => \"ensemble member numerical id\",\"standard_name\" => \"realization\"),\"time\" => Dict(\"units\" => \"seconds since 1970-01-01T00:00:00\",\"calendar\" => \"proleptic_gregorian\",\"long_name\" => \"initial time of forecast\",\"standard_name\" => \"forecast_reference_time\"),\"depthBelowLand\" => Dict(\"units\" => \"m\",\"long_name\" => \"soil depth\",\"standard_name\" => \"depth\",\"positive\" => \"down\"),\"hybrid\" => Dict(\"units\" => \"1\",\"long_name\" => \"hybrid level\",\"standard_name\" => \"atmosphere_hybrid_sigma_pressure_coordinate\",\"positive\" => \"down\"),\"depthBelowLandLayer\" => Dict(\"units\" => \"m\",\"long_name\" => \"soil depth\",\"standard_name\" => \"depth\",\"positive\" => \"down\"),\"isobaricLayer\" => Dict(\"units\" => \"Pa\",\"long_name\" => \"pressure\",\"standard_name\" => \"air_pressure\",\"positive\" => \"down\"),\"step\" => Dict(\"units\" => \"hours\",\"long_name\" => \"time since forecast_reference_time\",\"standard_name\" => \"forecast_period\"),\"isobaricInhPa\" => Dict(\"units\" => \"hPa\",\"stored_direction\" => \"decreasing\",\"long_name\" => \"pressure\",\"standard_name\" => \"air_pressure\",\"positive\" => \"down\"),\"isobaricInPa\" => Dict(\"units\" => \"Pa\",\"stored_direction\" => \"decreasing\",\"long_name\" => \"pressure\",\"standard_name\" => \"air_pressure\",\"positive\" => \"down\"),\"valid_time\" => Dict(\"units\" => \"seconds since 1970-01-01T00:00:00\",\"calendar\" => \"proleptic_gregorian\",\"long_name\" => \"time\",\"standard_name\" => \"time\"),\"indexing_time\" => Dict(\"units\" => \"seconds since 1970-01-01T00:00:00\",\"calendar\" => \"proleptic_gregorian\",\"long_name\" => \"nominal initial time of forecast\",\"standard_name\" => \"forecast_reference_time\"),\"heightAboveGround\" => Dict(\"units\" => \"m\",\"long_name\" => \"height above the surface\",\"standard_name\" => \"height\",\"positive\" => \"up\"),\"latitude\" => Dict(\"units\" => \"degrees_north\",\"long_name\" => \"latitude\",\"standard_name\" => \"latitude\"),\"longitude\" => Dict(\"units\" => \"degrees_east\",\"long_name\" => \"longitude\",\"standard_name\" => \"longitude\"),\"verifying_time\" => Dict(\"units\" => \"seconds since 1970-01-01T00:00:00\",\"calendar\" => \"proleptic_gregorian\",\"long_name\" => \"time\",\"standard_name\" => \"time\"))\n\n\n\n\n\n","category":"constant"},{"location":"lib/constants/#CfGRIB.DATA_ATTRIBUTES_KEYS","page":"Constants","title":"CfGRIB.DATA_ATTRIBUTES_KEYS","text":"[\"paramId\", \"shortName\", \"units\", \"name\", \"cfName\", \"cfVarName\", \"dataType\", \"missingValue\", \"numberOfPoints\", \"totalNumber\", \"numberOfDirections\", \"numberOfFrequencies\", \"typeOfLevel\", \"NV\", \"stepUnits\", \"stepType\", \"gridType\", \"gridDefinitionDescription\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/constants/#CfGRIB.DATA_TIME_KEYS","page":"Constants","title":"CfGRIB.DATA_TIME_KEYS","text":"[\"dataDate\", \"dataTime\", \"endStep\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/constants/#CfGRIB.ENSEMBLE_KEYS","page":"Constants","title":"CfGRIB.ENSEMBLE_KEYS","text":"[\"number\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/constants/#CfGRIB.GLOBAL_ATTRIBUTES_KEYS","page":"Constants","title":"CfGRIB.GLOBAL_ATTRIBUTES_KEYS","text":"[\"edition\", \"centre\", \"centreDescription\", \"subCentre\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/constants/#CfGRIB.GRID_TYPES_2D_NON_DIMENSION_COORDS","page":"Constants","title":"CfGRIB.GRID_TYPES_2D_NON_DIMENSION_COORDS","text":"[\"rotated_ll\", \"rotated_gg\", \"lambert\", \"albers\", \"polar_stereographic\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/constants/#CfGRIB.GRID_TYPES_DIMENSION_COORDS","page":"Constants","title":"CfGRIB.GRID_TYPES_DIMENSION_COORDS","text":"[\"regular_ll\", \"regular_gg\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/constants/#CfGRIB.GRID_TYPE_KEYS","page":"Constants","title":"CfGRIB.GRID_TYPE_KEYS","text":"[\"Nx\", \"Ny\", \"angleOfRotationInDegrees\", \"iDirectionIncrementInDegrees\", \"iScansNegatively\", \"jPointsAreConsecutive\", \"jScansPositively\", \"latitudeOfFirstGridPointInDegrees\", \"latitudeOfLastGridPointInDegrees\", \"latitudeOfSouthernPoleInDegrees\", \"longitudeOfFirstGridPointInDegrees\", \"longitudeOfLastGridPointInDegrees\", \"longitudeOfSouthernPoleInDegrees\", \"N\", \"M\", \"K\", \"J\", \"jDirectionIncrementInDegrees\", \"LaDInDegrees\", \"LoVInDegrees\", \"DyInMetres\", \"DxInMetres\", \"Latin2InDegrees\", \"Latin1InDegrees\", \"pl\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/constants/#CfGRIB.GRID_TYPE_MAP","page":"Constants","title":"CfGRIB.GRID_TYPE_MAP","text":"Dict(\"rotated_gg\" => [\"Nx\", \"Ny\", \"angleOfRotationInDegrees\", \"iDirectionIncrementInDegrees\", \"iScansNegatively\", \"jPointsAreConsecutive\", \"jScansPositively\", \"latitudeOfFirstGridPointInDegrees\", \"latitudeOfLastGridPointInDegrees\", \"latitudeOfSouthernPoleInDegrees\", \"longitudeOfFirstGridPointInDegrees\", \"longitudeOfLastGridPointInDegrees\", \"longitudeOfSouthernPoleInDegrees\", \"N\"],\"regular_gg\" => [\"Nx\", \"iDirectionIncrementInDegrees\", \"iScansNegatively\", \"longitudeOfFirstGridPointInDegrees\", \"longitudeOfLastGridPointInDegrees\", \"N\", \"Ny\"],\"sh\" => [\"M\", \"K\", \"J\"],\"regular_ll\" => [\"Nx\", \"iDirectionIncrementInDegrees\", \"iScansNegatively\", \"longitudeOfFirstGridPointInDegrees\", \"longitudeOfLastGridPointInDegrees\", \"Ny\", \"jDirectionIncrementInDegrees\", \"jPointsAreConsecutive\", \"jScansPositively\", \"latitudeOfFirstGridPointInDegrees\", \"latitudeOfLastGridPointInDegrees\"],\"lambert\" => [\"LaDInDegrees\", \"LoVInDegrees\", \"iScansNegatively\", \"jPointsAreConsecutive\", \"jScansPositively\", \"latitudeOfFirstGridPointInDegrees\", \"latitudeOfSouthernPoleInDegrees\", \"longitudeOfFirstGridPointInDegrees\", \"longitudeOfSouthernPoleInDegrees\", \"DyInMetres\", \"DxInMetres\", \"Latin2InDegrees\", \"Latin1InDegrees\", \"Ny\", \"Nx\"],\"reduced_gg\" => [\"N\", \"pl\"],\"rotated_ll\" => [\"Nx\", \"Ny\", \"angleOfRotationInDegrees\", \"iDirectionIncrementInDegrees\", \"iScansNegatively\", \"jDirectionIncrementInDegrees\", \"jPointsAreConsecutive\", \"jScansPositively\", \"latitudeOfFirstGridPointInDegrees\", \"latitudeOfLastGridPointInDegrees\", \"latitudeOfSouthernPoleInDegrees\", \"longitudeOfFirstGridPointInDegrees\", \"longitudeOfLastGridPointInDegrees\", \"longitudeOfSouthernPoleInDegrees\"],\"reduced_ll\" => [\"Ny\", \"jDirectionIncrementInDegrees\", \"jPointsAreConsecutive\", \"jScansPositively\", \"latitudeOfFirstGridPointInDegrees\", \"latitudeOfLastGridPointInDegrees\"])\n\n\n\n\n\n","category":"constant"},{"location":"lib/constants/#CfGRIB.SPECTRA_KEYS","page":"Constants","title":"CfGRIB.SPECTRA_KEYS","text":"[\"directionNumber\", \"frequencyNumber\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/constants/#CfGRIB.VERTICAL_KEYS","page":"Constants","title":"CfGRIB.VERTICAL_KEYS","text":"[\"level\"]\n\n\n\n\n\n","category":"constant"},{"location":"lib/backends/#","page":"Backends","title":"Backends","text":"Author = \"Robert Rosca\"","category":"page"},{"location":"lib/backends/#lib_backends-1","page":"Backends","title":"Backends","text":"","category":"section"},{"location":"lib/backends/#","page":"Backends","title":"Backends","text":"CfGRIB.jl has a flexible backend system built in to allow for multiple ways to represent multidimensional data with named dimensions.","category":"page"},{"location":"lib/backends/#","page":"Backends","title":"Backends","text":"Backends are loaded in dynamically based on what packages the user has available, currently there are two built-in backends, one is based on DimensionalData.jl and the other uses AxisArrays.","category":"page"},{"location":"lib/backends/#","page":"Backends","title":"Backends","text":"Additionally, FileIO.jl integration is prepared for each of the backends so that users utilising FileIO can use its smart load functions which will load the file via CfGRIB.jl when the correct file extension and magic numbers are present.","category":"page"},{"location":"lib/backends/#","page":"Backends","title":"Backends","text":"","category":"page"},{"location":"lib/backends/#","page":"Backends","title":"Backends","text":"Modules = [CfGRIB]\nPages   = [\"backends.jl\"]","category":"page"},{"location":"lib/backends/#","page":"Backends","title":"Backends","text":"Modules = [CfGRIB]\nPages   = [\"backends.jl\"]","category":"page"},{"location":"lib/backends/#CfGRIB.ArrayWrapper","page":"Backends","title":"CfGRIB.ArrayWrapper","text":"Summary\n\nabstract type ArrayWrapper <: CfGRIB.Backend\n\nAbstract type for backends which also wrap data types provided by external packages, instead of just providing a 'vanilla' implementation of the data type.\n\nPython's xarray has two fundamental data structures, a DataArray which holds the data for a single multi-dimensional variable and its coordinates, as well as a Dataset which holds multiple DataArrays that (typically) share the same coordinates.\n\nSee also\n\nAxisArrayWrapper, DimensionalArrayWrapper\n\nFields\n\nConstructors\n\n\n\n\n\n","category":"type"},{"location":"lib/backends/#CfGRIB.Backend","page":"Backends","title":"CfGRIB.Backend","text":"Summary\n\nabstract type Backend\n\nBackends are wrappers around named array data types, contain information on the dimensions, attributes, and encoding of the data, as well as the datasets themselves.\n\nSee also\n\nAxisArrayWrapper, DimensionalArrayWrapper\n\nFields\n\nConstructors\n\n\n\n\n\n","category":"type"},{"location":"lib/backends/#","page":"Backends","title":"Backends","text":"","category":"page"},{"location":"lib/backends/#","page":"Backends","title":"Backends","text":"Modules = [CfGRIB]\nPages   = [\"backends/axisarrays.jl\", \"backends/dimensionaldata.jl\"]","category":"page"},{"location":"lib/backends/#","page":"Backends","title":"Backends","text":"Modules = [CfGRIB]\nPages   = [\"backends/axisarrays.jl\", \"backends/dimensionaldata.jl\"]","category":"page"},{"location":"lib/backends/#CfGRIB.AxisArrayWrapper","page":"Backends","title":"CfGRIB.AxisArrayWrapper","text":"Summary\n\nstruct AxisArrayWrapper <: CfGRIB.ArrayWrapper\n\nAxisArrays provides the equivalent of an xarray DataArray, this wrapper adds the functionality of an xarray DataSet by containing multiple AxisArrays.\n\nObject should be created by calling the relevant convert(AxisArrayWrapper, dataset::DataSet) method on a DataSet.\n\nSee also\n\nBackend, ArrayWrapper\n\nFields\n\ndimensions::OrderedCollections.OrderedDict\nDictionary of DimensionName::String => DimensionLength::Int\ndatasets::NamedTuple\nNamed tuple of DatasetName::Symbol => Dataset::AxisArray\nattributes::OrderedCollections.OrderedDict\nDictionary of AttributeName::String => AttributeValue::Any\nencoding::Dict\nDictionary containing encoding information (usually source, filter_by_keys, and ecode_cf)\n\nConstructors\n\nAxisArrayWrapper(dimensions, datasets, attributes, encoding)\n\ndefined at /home/runner/work/cfgrib.jl/cfgrib.jl/src/backends/axisarrays.jl:31.\n\n\n\n\n\n","category":"type"},{"location":"lib/backends/#CfGRIB.DimensionalArrayWrapper","page":"Backends","title":"CfGRIB.DimensionalArrayWrapper","text":"Summary\n\nstruct DimensionalArrayWrapper <: CfGRIB.ArrayWrapper\n\nDimensionalData provides the equivalent of an xarray DataArray, this wrapper adds the functionality of an xarray DataSet by containing multiple DimensionalArrays.\n\nObject should be created by calling the relevant convert(DimensionalArrayWrapper, dataset::DataSet) method on a DataSet.\n\nSee also\n\nBackend, ArrayWrapper\n\nFields\n\ndimensions::OrderedCollections.OrderedDict\nDictionary of DimensionName::String => DimensionLength::Int\ndatasets::NamedTuple\nNamed tuple of DatasetName::Symbol => Dataset::DimensionalArray\nattributes::OrderedCollections.OrderedDict\nDictionary of AttributeName::String => AttributeValue::Any\nencoding::Dict\nDictionary containing encoding information (usually source, filter_by_keys, and ecode_cf)\n\nConstructors\n\nDimensionalArrayWrapper(dimensions, datasets, attributes, encoding)\n\ndefined at /home/runner/work/cfgrib.jl/cfgrib.jl/src/backends/dimensionaldata.jl:31.\n\n\n\n\n\n","category":"type"},{"location":"man/guide/#Start-Guide-1","page":"Manual","title":"Start Guide","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"This is a quick start guide for how to begin using CfGRIB.jl, we'll go through the basics of how the package works, and then how to use it to load and interact with some basic data structures.","category":"page"},{"location":"man/guide/#Internals-1","page":"Manual","title":"Internals","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"The package internals are covered in the library section of the documentation in greater detail, however it is useful to have a vague sense of what is happening when you load a dataset.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"First, we load the package, and for convenience create a string pointing to our file path:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"using CfGRIB\n\nsample_data_dir = abspath(joinpath(dirname(pathof(CfGRIB)), \"..\", \"test\", \"sample-data\"))\n\ndemo_file_path = joinpath(sample_data_dir, \"era5-levels-members.grib\")","category":"page"},{"location":"man/guide/#FileIndex-1","page":"Manual","title":"FileIndex","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"Whenever you load a grib file, the first thing that happens is that the file index is read. The file index contains metadata which describes which messages contain what information inside the file. We can explore the index by manually creating a FileIndex object.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"First, we can look at the docstring for the FileIndex constructor by typing in ? at the REPL to enter help mode, then type in CfGRIB.FileIndex, press enter, and we get the docstring:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"help?> CfGRIB.FileIndex\n  Summary\n  ≡≡≡≡≡≡≡≡≡\n\n  mutable struct FileIndex\n\n  A mutable store for indices of a GRIB file\n\n  TODO: Should probably change this to a immutable struct\n\n  Fields\n  ≡≡≡≡≡≡≡≡\n\n    •    allowed_protocol_version::VersionNumber\n\n        Version number used when saving/hashing index files, should change if\n        the indexing structure changes breaking backwards-compatibility\n\n    •    grib_path::String\n\n        Path to the file the index belongs to\n\n    •    index_path::String\n\n        Path to the index cache file\n\n    •    index_keys::Array{String,1}\n\n        Array containing all of the index keys\n\n    •    offsets::Array{Pair{NamedTuple,Int64},1}\n\n        Array containing pairs of offsets[HeaderTuple(header_values)] => offset_field\n\n    •    message_lengths::Array{Int64,1}\n\n        Array containing the length of each message in the GRIB file\n\n    •    header_values::OrderedCollections.OrderedDict{String,Array}\n\n        Dictionary of all of the loaded header values in the GRIB file\n\n    •    filter_by_keys::Dict\n\n        Filters used when creating the file index\n\n  Constructors\n  ≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\n  FileIndex()\n\n  defined at dev/CfGRIB/src/indexing.jl:34\n  (https://github.com/RobertRosca/cfgrib.jl/tree/5ced129d540ed9a1ff57da48c9b4f047b17d936d//src/indexing.jl#L34).\n\n  FileIndex(grib_path, index_keys)\n\n  defined at dev/CfGRIB/src/indexing.jl:38\n  (https://github.com/RobertRosca/cfgrib.jl/tree/5ced129d540ed9a1ff57da48c9b4f047b17d936d//src/indexing.jl#L38).","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"The docstring is quite long, it explains the fields contained in the object, as well as giving a list of the constructors which can be used to create an instance of the object.","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"We'll use the second constructor, which takes in a path to the file and a list of keys. First, we pick which keys we want to use. In this case we'll just use the ALL_KEYS constant:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"println(CfGRIB.ALL_KEYS)\n\nindex = CfGRIB.FileIndex(\n           demo_file_path,\n           CfGRIB.ALL_KEYS\n       );","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"From here you can explore fields contained in this object. Typically you will never interact with the FileIndex directly, as it's just used in the background to load the data.","category":"page"},{"location":"man/guide/#DataSet-1","page":"Manual","title":"DataSet","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"Once the FileIndex has been created, the next step is to use it to create a DataSet object. The DataSet is what what you use to access the stored data. The docstring says:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"help?> CfGRIB.DataSet\n  Summary\n  ≡≡≡≡≡≡≡≡≡\n\n  struct DataSet\n\n  Map a GRIB file to the NetCDF Common Data Model with CF Conventions.\n\n  Fields\n  ≡≡≡≡≡≡≡≡\n\n    •    dimensions::OrderedCollections.OrderedDict{String,Int64}\n\n        OrderedDict{String,Int} of $DIMENSION_NAME => $DIMENSION_LENGTH.\n\n    •    variables::OrderedCollections.OrderedDict{String,CfGRIB.Variable}\n\n        OrderedDict{String,CfGRIB.Variable} of $DIMENSION_NAME => $DIMENSION_VARIABLE, where the the variable is a CfGRIB.jl Variable.\n\n    •    attributes::OrderedCollections.OrderedDict{String,Any}\n\n        OrderedDict{String,Any} containing some metadata extracted from the file.\n\n    •    encoding::Dict{String,Any}\n\n        Dict{String,Any} containing metadata related to CfGRIB.jl, e.g. filter_by_keys\n\n  Constructors\n  ≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\n  DataSet(dimensions, variables, attributes, encoding)\n\n  defined at dev/CfGRIB/src/dataset.jl:127\n  (https://github.com/RobertRosca/cfgrib.jl/tree/5ced129d540ed9a1ff57da48c9b4f047b17d936d//src/dataset.jl#L127).\n\n  DataSet(path; read_keys, kwargs...)\n\n  defined at dev/CfGRIB/src/dataset.jl:140\n  (https://github.com/RobertRosca/cfgrib.jl/tree/5ced129d540ed9a1ff57da48c9b4f047b17d936d//src/dataset.jl#L140).","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"Here we see references to Variable, so we'll briefly explain those.","category":"page"},{"location":"man/guide/#Variable-1","page":"Manual","title":"Variable","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"A Variable is a basic struct in CfGRIB.jl which contains information for a variable read from a GRIB file:","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"help?> CfGRIB.Variable\n  Summary\n  ≡≡≡≡≡≡≡≡≡\n\n  struct Variable\n\n  Struct describing a cfgrib variable\n\n  Fields\n  ≡≡≡≡≡≡≡≡\n\n    •    dimensions::Tuple{Vararg{String,N} where N}\n\n        Name of the dimension(s) contained in this variable\n\n    •    data::Union{CfGRIB.OnDiskArray, Number, Array}\n\n        Data contained in the variable, can point ot in-memory data or to a CfGRIB\n        OnDiskArray\n\n    •    attributes::Dict{String,Any}\n\n        Dictionary containing metadata for the variable, typically the units, the long name,\n        and the standard name\n\n  Constructors\n  ≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\n  Variable(dimensions, data, attributes)\n\n  defined at dev/CfGRIB/src/dataset.jl:108\n  (https://github.com/RobertRosca/cfgrib.jl/tree/5ced129d540ed9a1ff57da48c9b4f047b17d936d//src/dataset.jl#L108).","category":"page"},{"location":"man/guide/#OnDiskArray-1","page":"Manual","title":"OnDiskArray","text":"","category":"section"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"TODO","category":"page"},{"location":"man/guide/#","page":"Manual","title":"Manual","text":"help?> CfGRIB.OnDiskArray\n  Summary\n  ≡≡≡≡≡≡≡≡≡\n\n  struct OnDiskArray\n\n  Struct that contains metadata for an array, used to lazy-load the array from disk only when\n  requested\n\n  Fields\n  ≡≡≡≡≡≡≡≡\n\n    •    grib_path::String\n\n    •    size::Tuple\n\n    •    offsets::OrderedCollections.OrderedDict\n\n    •    message_lengths::Array{Int64,1}\n\n    •    missing_value::Any\n\n    •    geo_ndim::Int64\n\n    •    dtype::Type\n\n  Constructors\n  ≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\n  OnDiskArray(grib_path, size, offsets, message_lengths, missing_value, geo_ndim, dtype)\n\n  defined at dev/CfGRIB/src/dataset.jl:27\n  (https://github.com/RobertRosca/cfgrib.jl/tree/5ced129d540ed9a1ff57da48c9b4f047b17d936d//src/dataset.jl#L27).","category":"page"},{"location":"lib/dataset/#","page":"Dataset","title":"Dataset","text":"Author = \"Robert Rosca\"","category":"page"},{"location":"lib/dataset/#lib_dataset-1","page":"Dataset","title":"Dataset","text":"","category":"section"},{"location":"lib/dataset/#","page":"Dataset","title":"Dataset","text":"The dataset file contains the majority of the core code in CfGRIB.jl. It defines the key datatypes used throughout the package, as well as how data is read from the disk and how it gets interpreted.","category":"page"},{"location":"lib/dataset/#","page":"Dataset","title":"Dataset","text":"","category":"page"},{"location":"lib/dataset/#","page":"Dataset","title":"Dataset","text":"Modules = [CfGRIB]\nPages   = [\"dataset.jl\"]","category":"page"},{"location":"lib/dataset/#","page":"Dataset","title":"Dataset","text":"Modules = [CfGRIB]\nPages   = [\"dataset.jl\"]","category":"page"},{"location":"lib/dataset/#CfGRIB.DataSet","page":"Dataset","title":"CfGRIB.DataSet","text":"Summary\n\nstruct DataSet\n\nMaps a GRIB file to the NetCDF Common Data Model with CF Conventions.\n\nFields\n\ndimensions::OrderedCollections.OrderedDict{String,Int64}\nOrderedDict{String,Int} of $DIMENSION_NAME => $DIMENSION_LENGTH.\nvariables::OrderedCollections.OrderedDict{String,CfGRIB.Variable}\nOrderedDict{String,CfGRIB.Variable} of $DIMENSION_NAME => $DIMENSION_VARIABLE, where the the variable is a Variable.\nattributes::OrderedCollections.OrderedDict{String,Any}\nOrderedDict{String,Any} containing some metadata extracted from the file.\nencoding::Dict{String,Any}\nDict{String,Any} containing metadata related to CfGRIB.jl, e.g. filter_by_keys\n\nConstructors\n\nDataSet(dimensions, variables, attributes, encoding)\n\ndefined at /home/runner/work/cfgrib.jl/cfgrib.jl/src/dataset.jl:136.\n\nDataSet(path; encode_cf, errors, filter_by_keys, read_keys, squeeze, time_dims)\n\ndefined at /home/runner/work/cfgrib.jl/cfgrib.jl/src/dataset.jl:153.\n\n\n\n\n\n","category":"type"},{"location":"lib/dataset/#CfGRIB.OnDiskArray","page":"Dataset","title":"CfGRIB.OnDiskArray","text":"Summary\n\nstruct OnDiskArray\n\nStruct that contains metadata for an array, used to lazy-load the array from disk only when requested\n\nFields\n\ngrib_path::String\nsize::Tuple\noffsets::OrderedCollections.OrderedDict\nmessage_lengths::Array{Int64,1}\nmissing_value::Any\ngeo_ndim::Int64\ndtype::Type\n\nConstructors\n\nOnDiskArray(grib_path, size, offsets, message_lengths, missing_value, geo_ndim, dtype)\n\ndefined at /home/runner/work/cfgrib.jl/cfgrib.jl/src/dataset.jl:27.\n\n\n\n\n\n","category":"type"},{"location":"#","page":"Home","title":"Home","text":"Modules = [CfGRIB]\nPages   = [\"CfGRIB.jl\"]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [CfGRIB]\nPages   = [\"CfGRIB.jl\"]","category":"page"},{"location":"#CfGRIB.CfGRIB","page":"Home","title":"CfGRIB.CfGRIB","text":"CfGRIB.jl\n\n(Image: lifecycle) (Image: latest release) (Image: Apache 2 license)\n\n(Image: Build Status) (Image: Build Status) (Image: Codecov)\n\n(Image: ) (Image: Code Style: Blue)\n\nDescription\n\nCfGRIB.jl is a julia interface to map GRIB files to the Unidata's Common Data Model v4 following the CF Conventions.\n\nThis package is based on the python implementation in cfgrib.py and closely follows the approaches of that package, but in Julia instead. Parity tests are automatically performed between the two to ensure that the data returned by the Julia version is equivalent to that from Python.\n\nIn Python xarray has come out to be a standard way to implement named arrays, however as Julia is a much younger language no stable array interface has been adopted by the community yet, so the approach here is more flexible and allows for multiple array backends to be used.\n\nLow level access and decoding is performed by calling GRIB.jl which itself calls the ECMWF ecCodes library.\n\nInstallation\n\nThe package is currently under heavy development so it has not been added to the Julia package registry yet. To install the package first clone this repository:\n\ngit clone https://github.com/robertrosca/CfGRIB.jl/\ncd CfGRIB.jl\n\nThen start Julia, enter the pkg mode, activate the project (projects are similar to python venv's), install the GRIB.jl package (as it is also not on the registry), and then finally you can instantiate CfGRIB.jl to get the rest of the dependencies:\n\nactivate .\nadd https://github.com/weech/GRIB.jl\ninstantiate\n\nFinally exit pkg mode by pressing backspace, and use the package as usual:\n\nusing CfGRIB\n\n\n\n\n\n","category":"module"}]
}
